<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="canonical" href="http://yut.hatenablog.com/entry/20130128/1359327329" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.55.4" />

  <title>JavaでMapReduceを書くことが出来ない問題児がPigのデータ構造を調査しました &middot; Y&#39;s note</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://yutakikuchi.github.io/blog/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://yutakikuchi.github.io/blog/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://yutakikuchi.github.io/blog/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://yutakikuchi.github.io/blog/img/favicon.ico" type="image/x-icon" />

  
    
        <link rel="stylesheet" href="https://yutakikuchi.github.io/blog/css/my.css">
    
  
  
    
        <script src="https://yutakikuchi.github.io/blog/js/my.js"></script>
    
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://yutakikuchi.github.io/blog/">Y's note</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://yutakikuchi.github.io/blog/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://yutakikuchi.github.io/blog/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://yutakikuchi.github.io/blog/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/yutakikuchi_" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://facebook.com/yuta.kikuchi.007" target="_blank"><i class="fa fa-facebook-square fa-fw"></i>Facebook</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://slideshare.net/https://www.slideshare.net/yutakikuchi58/" target="_blank"><i class="fa fa-slideshare fa-fw"></i>SlideShare</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://linkedin.com/in/https://www.linkedin.com/in/%E4%BD%91%E5%A4%AA-%E8%8F%8A%E6%B1%A0-36291a44/" target="_blank"><i class="fa fa-linkedin-square fa-fw"></i>LinkedIn</a>
    </li>
    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yutakikuchi" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2019. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>JavaでMapReduceを書くことが出来ない問題児がPigのデータ構造を調査しました</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2013 Jan 28, 07:55</time>
  </div>

  

  

  

</div>

  

<h2 id="hadoop-javaでmapreduceを書くことが出来ない問題児がpigのデータ構造を調査しました">[Hadoop] : JavaでMapReduceを書くことが出来ない問題児がPigのデータ構造を調査しました</h2>

<p><div class="amazlet-box"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/B0065KVFBM/yutakikuchi-22/"><img src="http://ecx.images-amazon.com/images/I/51uduVrZotL._SL160_.jpg" class="hatena-asin-detail-image" alt="Programming Pig" title="Programming Pig"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/B0065KVFBM/yutakikuchi-22/">Programming Pig</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> <a class="keyword" href="http://d.hatena.ne.jp/keyword/Alan">Alan</a> Gates</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> O'Reilly Media</li><li><span class="hatena-asin-detail-label">発売日:</span> 2011/09/29</li><li><span class="hatena-asin-detail-label">メディア:</span> <a class="keyword" href="http://d.hatena.ne.jp/keyword/Kindle">Kindle</a>版</li><li><a href="http://d.hatena.ne.jp/asin/B0065KVFBM/yutakikuchi-22" target="_blank">この商品を含むブログ (1件) を見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p>

<div class="section">
<h4>本当は<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>で書きたい。けど<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB">コンパイル</a>や多段<a class="keyword" href="http://d.hatena.ne.jp/keyword/MapReduce">MapReduce</a>は面倒なので</h4>

<blockquote>
    <p>まずは僕の面倒くさがりな性格と<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC">プログラミング言語</a>の話。10年前は<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>でWebアプリを書いていましたが、就職してScript言語をばりばり使っていた時期が長く続いたので<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>から遠ざかってしまいました。もともと<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB">コンパイル</a>が嫌いで、環境を整えたり直ぐに動作確認ができなかったり。スピードを求められる単純作業がその面倒な事によって時間が削られることを嫌っています。(自分でも良くないことだと思っていますので、今後は時間が有るときに<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>を書いてみます)JavaMapReduceは柔軟であり速度的にも速いことは知っています。ただ<a class="keyword" href="http://d.hatena.ne.jp/keyword/MapReduce">MapReduce</a>で複雑なデータのJoinやデータ集計を行うためには多段の<a class="keyword" href="http://d.hatena.ne.jp/keyword/MapReduce">MapReduce</a>を書かざるを得ないこともあり、単純集計のコードを<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4">複数</a>管理することもまた面倒に感じられてしまいます。<br />
という事で、僕は<a class="keyword" href="http://d.hatena.ne.jp/keyword/Hadoop">Hadoop</a>集計ではPigを使うことにしました(笑) <span class="deco" style="color:#FF0000;">Pigは<a class="keyword" href="http://d.hatena.ne.jp/keyword/SQL">SQL</a>チックなLatinでデータをパズル的に組み合わせてデータ集計が可能</span>です。速度的には当然JavaMapReduceよりは遅くなってしまいますが(たしか平均で1.5倍ぐらい遅くなる)、一つのScriptで柔軟なデータ組み合わせができます。<br />
Pigの良いところはたったの数行で強力なデータの組み合わせが表現できること、悪いところは1行の表現が難しく自分の直感とは全く異なる挙動をすることがあるので細かくDESCRIBEを用いてデータの形式を確認する必要があります。以前に自分のメモとしてPigの内容を紹介をしました。今日はデータの格納と組み合わせのTipsについて紹介したいと思います。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/yutakikuchi/20130107/1357514830">10分でHadoop-Pigの基本文法を理解する - Yuta.Kikuchiの日記</a> <a href="http://b.hatena.ne.jp/entry/d.hatena.ne.jp/yutakikuchi/20130107/1357514830"><img src="http://b.hatena.ne.jp/entry/image/http://d.hatena.ne.jp/yutakikuchi/20130107/1357514830" alt="はてなブックマーク - 10分でHadoop-Pigの基本文法を理解する - Yuta.Kikuchiの日記" border="0" /></a></li>
<li><a href="http://d.hatena.ne.jp/yutakikuchi/20121217/1355700637">PigでHadoopをより便利に使う！PigでのMapReduceまとめ - Yuta.Kikuchiの日記</a> <a href="http://b.hatena.ne.jp/entry/d.hatena.ne.jp/yutakikuchi/20121217/1355700637"><img src="http://b.hatena.ne.jp/entry/image/http://d.hatena.ne.jp/yutakikuchi/20121217/1355700637" alt="はてなブックマーク - PigでHadoopをより便利に使う！PigでのMapReduceまとめ - Yuta.Kikuchiの日記" border="0" /></a></li>
<li><a href="http://d.hatena.ne.jp/yutakikuchi/20121229/1356759173">Hadoop Oozie設定からPigのPythonUDFを利用するまでのまとめ - Yuta.Kikuchiの日記</a> <a href="http://b.hatena.ne.jp/entry/d.hatena.ne.jp/yutakikuchi/20121229/1356759173"><img src="http://b.hatena.ne.jp/entry/image/http://d.hatena.ne.jp/yutakikuchi/20121229/1356759173" alt="はてなブックマーク - Hadoop Oozie設定からPigのPythonUDFを利用するまでのまとめ - Yuta.Kikuchiの日記" border="0" /></a></li>
</ul>
</blockquote>

</div>
<div class="section">
<h4>Index</h4>

<blockquote>
    
<ol>
<li>Pigのデータ構造調査
<ol>
<li>Latinの日本語ドキュメント</li>
<li>DataFormatの確認にDESCRIBEを利用する</li>
<li>tuple,bagの中身を参照する</li>
<li>InputからOutputしたいDataFormatを考える</li>
<li>JOINとCOGROUPでは参照の仕方が異なる</li>
<li>JOIN/COGROUPのBY属性にnull項目があるときは気をつける</li>
<li>STOREした時のtuple/bag/mapは文字列として保存される。再度LOADする時はPig形式のデータで読み込みたい時はASで指定する</li>
</ol></li>
<li>その他
<ol>
<li>文法をCheckしてlocalで実行し、問題なければ<a class="keyword" href="http://d.hatena.ne.jp/keyword/HDFS">HDFS</a>上で<a class="keyword" href="http://d.hatena.ne.jp/keyword/MapReduce">MapReduce</a>させる</li>
<li>Reducerの数を調節したい</li>
<li>STOREするDataを<a class="keyword" href="http://d.hatena.ne.jp/keyword/gzip">gzip</a>圧縮したい</li>
</ol></li>
</ol>
</blockquote>

</div>
<div class="section">
<h4>Pig データ構造調査</h4>

<blockquote>
    
<div class="section">
<h5>Latinの日本語ドキュメント</h5>
<p>Pigに関する日本語のドキュメントは次のページを見ると詳しく載っています。<br />
<a href="http://s3-ap-northeast-1.amazonaws.com/pig.doc.ja/basic.html#deref">Pig Latin の基本</a> <a href="http://b.hatena.ne.jp/entry/s3-ap-northeast-1.amazonaws.com/pig.doc.ja/basic.html%23deref"><img src="http://b.hatena.ne.jp/entry/image/http://s3-ap-northeast-1.amazonaws.com/pig.doc.ja/basic.html%23deref" alt="はてなブックマーク - Pig Latin の基本" border="0" /></a><br />
</p>

</div>
<div class="section">
<h5>DataFormatの確認に<span class="deco" style="color:#FF0000;">DESCRIBE</span>を利用する</h5>
<pre class="code" data-lang="" data-unlink>/* input */
John 17 Men youtube
John 17 Men yahoo
Kate 18 Women facebook
Kate 18 Women ebay
Kate 18 Women ebay
Tom 19 Men google</pre><p>まずはDESCRIBEを覚えると良いです。DESCRIBEは変数(alias)がどういったDataFormatなのかをコンソールに出力してくれます。Pig内部のData操作は<span class="deco" style="color:#FF0000;">DESCRIBEで出力してみないと良くわからない</span>ことが多いです。変数の中身を確認するにはDUMPで結果を出力するか、STOREで結果ファイルパスに格納することができますが、LOADのデータサイズが大きいと実行に時間がかかってしまうのと複雑なPigは変数にどの変数の一部が格納されているのかが分かりづらくなってしまうので、開発中はDESCRIBEで変数のDataFormatだけをDebug出力して、コードをどんどん書いていくと良いでしょう。下のInputとSampleのPigコードに対してDESCRIBEさせた結果を見てみます。group_dataは名前、年齢、性別、閲覧Domainで共通GROUP化しています。下の説明だけで奥が深くなってしまうのですが、group_dataには共通項として設定したname/age/gen/domainがtuple形式のgroupとして、グルーピングされたdata部分がbag形式として保存されます。<span class="deco" style="color:#FF0000;">groupという<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%C7%A1%BC%A5%BF%B7%C1%BC%B0">データ形式</a>はGROUPを使った場合に付与されるデータ群、tupleは( )で表現される単純なデータの入れ物、Bagは{ } で表現される色々な種類のデータの入れ物</span>としてまずは覚えておくといいと思います。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data = <span class="synSpecial">GROUP</span> data <span class="synSpecial">BY</span> ( name, age, gen, domain );
DESCRIBE group_data;
DUMP group_data;

<span class="synComment">/* DESCRIBEの結果 */</span>
group_data: {<span class="synSpecial">group</span>: (name: chararray,age: int,gen: chararray,domain: chararray),data: {name: chararray,age: int,gen: chararray,domain: chararray}} 

<span class="synComment">/* 出力結果 */</span>
((Tom,<span class="synConstant">19</span>,Men,google),{(Tom,<span class="synConstant">19</span>,Men,google)})
((John,<span class="synConstant">17</span>,Men,yahoo),{(John,<span class="synConstant">17</span>,Men,yahoo)})
((John,<span class="synConstant">17</span>,Men,youtube),{(John,<span class="synConstant">17</span>,Men,youtube)})
((Kate,<span class="synConstant">18</span>,Women,ebay),{(Kate,<span class="synConstant">18</span>,Women,ebay),(Kate,<span class="synConstant">18</span>,Women,ebay)})
((Kate,<span class="synConstant">18</span>,Women,facebook),{(Kate,<span class="synConstant">18</span>,Women,facebook)})
</pre><p><span itemscope itemtype="http://schema.org/Photograph"><a href="http://f.hatena.ne.jp/yutakikuchi/20130126130919" class="hatena-fotolife" itemprop="url"><img src="http://cdn-ak.f.st-hatena.com/images/fotolife/y/yutakikuchi/20130126/20130126130919.png" alt="f:id:yutakikuchi:20130126130919p:image:w360" title="f:id:yutakikuchi:20130126130919p:image:w360" class="hatena-fotolife" style="width:360px" itemprop="image"></a></span><br />
</p>

</div>
<div class="section">
<h5>tuple,bagの中身を参照する</h5>
<p>tuple,bagともに中身を参照したい場合は.(ドット)を利用します。(tuple/bag名.名前)ドットを参照外し<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2">演算子</a>と読んでいるようです。hash型のmapデータ型の場合はmap名#keyと指定します。tupleとbagの参照では少しデータの取り方に違いがあります。下のコードの例を見てみます。group_dataの中身であるtupleのgroupからname,ageをbagのdataからそれぞれデータを参照しようとしていますが、bagの方は出力がまだbag形式になってしまっています。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data = <span class="synSpecial">GROUP</span> data <span class="synSpecial">BY</span> ( name, age, gen, domain );
ref_data = FOREACH group_data GENERATE <span class="synSpecial">group</span>.name <span class="synSpecial">AS</span> gname, <span class="synSpecial">group</span>.age <span class="synSpecial">AS</span> gage, data.gen <span class="synSpecial">AS</span> dgen, data.domain <span class="synSpecial">AS</span> ddomain;
DUMP ref_data;

<span class="synComment">/* 出力結果 */</span>
(Tom,<span class="synConstant">19</span>,{(Men)},{(google)})
(John,<span class="synConstant">17</span>,{(Men)},{(yahoo)})
(John,<span class="synConstant">17</span>,{(Men)},{(youtube)})
(Kate,<span class="synConstant">18</span>,{(Women),(Women)},{(ebay),(ebay)})
(Kate,<span class="synConstant">18</span>,{(Women)},{(facebook)})
</pre><p>bagの中身をtupleと同様に参照したい場合は<span class="deco" style="color:#FF0000;">FLATTEN</span>でbagを強制的に解除することができますが、その場合は折角のGROUPが外れて独立組み合わせが出力されてしまいますのでFLATTENを使う場合は注意が必要です。下の例では試しにdata.genを平坦化させてみました。そうするとbagが外れています。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data = <span class="synSpecial">GROUP</span> data <span class="synSpecial">BY</span> ( name, age, gen, domain );
ref_data = FOREACH group_data GENERATE <span class="synSpecial">group</span>.name <span class="synSpecial">AS</span> gname, <span class="synSpecial">group</span>.age <span class="synSpecial">AS</span> gage, FLATTEN( data.gen ) <span class="synSpecial">AS</span> dgen, data.domain <span class="synSpecial">AS</span> ddomain;
DUMP ref_data;

<span class="synComment">/* 出力結果 */</span>
(Tom,<span class="synConstant">19</span>,Men,{(google)})
(John,<span class="synConstant">17</span>,Men,{(yahoo)})
(John,<span class="synConstant">17</span>,Men,{(youtube)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay),(ebay)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay),(ebay)})
(Kate,<span class="synConstant">18</span>,Women,{(facebook)})
</pre>
</div>
<div class="section">
<h5>InputからOutputしたいDataFormatを考える</h5>
<p>下のようなInputに対してどのようなOutputを出したいのかをまずは考えます。例では名前、年齢、性別、どのサイトを見ているかという履歴リストから重複行をカウントすることを考えます。前提条件として名前、年齢、性別の組み合わせはユニークで、サイト名だけ重複する可能性がある例です。手段としては1.名前、年齢、性別、サイト名でデータを<span class="deco" style="color:#FF0000;">GROUP</span>させて、2.GROUPされたデータ行を<span class="deco" style="color:#FF0000;">COUNT</span>するという方法です。</p>
<pre class="code" data-lang="" data-unlink>/* input */
John 17 Men youtube
John 17 Men yahoo
Kate 18 Women facebook
Kate 18 Women ebay
Kate 18 Women ebay
Tom 19 Men google

/* outputしたい内容 */
John 17 Men youtube 1
John 17 Men yahoo 1
Kate 18 Women facebook 1
Kate 18 Women ebay 2
Tom 19 Men google 1</pre><pre class="hljs sql" data-lang="sql" data-unlink>data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data = <span class="synSpecial">GROUP</span> data <span class="synSpecial">BY</span> ( name, age, gen, domain );
count_data = FOREACH group_data GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain, COUNT( data.domain );
DUMP count_data;

<span class="synComment">/* 出力結果 */</span>
(Tom,<span class="synConstant">19</span>,Men,google,<span class="synConstant">1</span>)
(John,<span class="synConstant">17</span>,Men,yahoo,<span class="synConstant">1</span>)
(John,<span class="synConstant">17</span>,Men,youtube,<span class="synConstant">1</span>)
(Kate,<span class="synConstant">18</span>,Women,ebay,<span class="synConstant">2</span>)
(Kate,<span class="synConstant">18</span>,Women,facebook,<span class="synConstant">1</span>)
</pre><p>Pigの3行目を少し変えた記述もできます。groupを直接参照しないで<span class="deco" style="color:#FF0000;">FLATTEN</span>を用いて解除させてあげる方法です。tupleを平坦化したデータなので展開後の名前をASで付与しています。結果としては上と同じなのでどちらの記述でも構わないと思います。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data = <span class="synSpecial">GROUP</span> data <span class="synSpecial">BY</span> ( name, age, gen, domain );
count_data = FOREACH group_data GENERATE FLATTEN( <span class="synSpecial">group</span> ) <span class="synSpecial">AS</span> ( name, age, gen, domain ), COUNT( data.domain );
<span class="synComment">-- count_data = FOREACH group_data GENERATE group.name, group.age, group.gen, group.domain, COUNT( data.domain );</span>
DUMP count_data;

<span class="synComment">/* 上と同じ結果が出力される */</span>
(Tom,<span class="synConstant">19</span>,Men,google,<span class="synConstant">1</span>)
(John,<span class="synConstant">17</span>,Men,yahoo,<span class="synConstant">1</span>)
(John,<span class="synConstant">17</span>,Men,youtube,<span class="synConstant">1</span>)
(Kate,<span class="synConstant">18</span>,Women,ebay,<span class="synConstant">2</span>)
(Kate,<span class="synConstant">18</span>,Women,facebook,<span class="synConstant">1</span>)
</pre><p>上の結果を更に名前、年齢、性別のIndexをユニーク化して、サイト名とカウント数をIndexの後に追記したいとします。この場合は一つ上の例から更に名前、年齢、性別でGROUP化します。サイト名とカウント数をtupleで表現し、更にそれをbagで囲むようにします。ここでのポイントは2回目のGROUP後のFOREACHでbag名.( <a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE">カラム名</a>1, <a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE">カラム名</a>2 )のようにtupleを参照しているところです。ここでTOTUPLE関数を利用してTOTUPLE( bag名.<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE">カラム名</a>1, bag名.<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE">カラム名</a>2 )とすると全く異なる結果になってしまうので注意が必要です。同様にTOBAG関数を使う時も注意が必要です。不用意に利用してしまうと意図しないデータが生成されてしまいます。<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%C7%A1%BC%A5%BF%B7%C1%BC%B0">データ形式</a>としてlist_data1.domainとlist_data1.cntのそれぞれが<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4">複数</a>のデータを持つbag形式になっていることが分かれば理解できるかと思います。</p>
<pre class="code" data-lang="" data-unlink>/* input */
John 17 Men youtube
John 17 Men yahoo
Kate 18 Women facebook
Kate 18 Women ebay
Kate 18 Women ebay
Tom 19 Men google

/* outputしたい内容 */
John 17 Men {( youtube, 1), (yahoo, 1)}
Kate 18 Women {(facebook, 1), (ebay, 2)}
Tom 19 Men {(google, 1)}</pre><pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain <span class="synSpecial">AS</span> domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt; 

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.(domain, cnt );
DUMP list_data1_uniq;

<span class="synComment">/* 出力したかった内容が表現できた */</span>
(Tom,<span class="synConstant">19</span>,Men,{(google,<span class="synConstant">1</span>)})
(John,<span class="synConstant">17</span>,Men,{(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)})
</pre><pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain <span class="synSpecial">AS</span> domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, TOTUPLE( list_data1.domain, list_data1.cnt );
DUMP list_data1_uniq;

<span class="synComment">/* サイト名、カウントがそれぞれまとめられて、最終的に全部の項目がtupleとして出力される */</span>
(Tom,<span class="synConstant">19</span>,Men,({(google)},{(<span class="synConstant">1</span>)}))
(John,<span class="synConstant">17</span>,Men,({(yahoo),(youtube)},{(<span class="synConstant">1</span>),(<span class="synConstant">1</span>)}))
(Kate,<span class="synConstant">18</span>,Women,({(ebay),(facebook)},{(<span class="synConstant">2</span>),(<span class="synConstant">1</span>)}))
</pre><p>もう一つ<span class="deco" style="color:#FF0000;">TOTUPLEを使った時の誤った例</span>を紹介します。一つ目のGROUP後のFOREACHでTOTUPLEを利用してdomainとCOUNTの組みをtuple化しようとします。こうしてしまうと2回目のGROUP後のFOREACHで余計にtupleが生成されてしまいます。どうやらFOREACHでは対象データが<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4">複数</a>存在する場合には自動的にbagが生成され、更にbag内をtuple化してくれるようなので、あえて自分でTOTUPLEを使わなくても良いということが分かります。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, TOTUPLE( <span class="synSpecial">group</span>.domain, COUNT( data1.domain )) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.cnt;
DUMP list_data1_uniq;

<span class="synComment">/* tuple( domain, count )の外に更にtupleが付与されてしまっている */</span>
(Tom,<span class="synConstant">19</span>,Men,{((google,<span class="synConstant">1</span>))})
(John,<span class="synConstant">17</span>,Men,{((yahoo,<span class="synConstant">1</span>)),((youtube,<span class="synConstant">1</span>))})
(Kate,<span class="synConstant">18</span>,Women,{((ebay,<span class="synConstant">2</span>)),((facebook,<span class="synConstant">1</span>))})
</pre>
</div>
<div class="section">
<h5>JOINとCOGROUPでは参照の仕方が異なる</h5>
<p>2つ以上のデータを結合するJOINとCOGROUPですが、それらの結果に対するデータの参照方法が異なります。ここも良く陥るところなので注意が必要です。例としてinput1は今までと同じもの、input2では趣味のデータを追加しました。これらのデータを<span class="deco" style="color:#FF0000;">OUTER JOIN(外部結合)</span>をしたいと考えます。外部結合にはJOINかCOGROUPが必要で、まずはJOINの例から紹介します。JOINのDESCRIBEを見るとlist_data1_uniq::nameのようにタブルコロンが使用されており、<span class="deco" style="color:#FF0000;">JOINのデータ参照にはダブルコロンを指定しないといけません</span>。(GROUPはドットだったりややこしいですね)</p>
<pre class="code" data-lang="" data-unlink>/* input1 */
John 17 Men youtube
John 17 Men yahoo
Kate 18 Women facebook
Kate 18 Women ebay
Kate 18 Women ebay
Tom 19 Men google

/* input2 */
John 17 Men soccer 
Ken 17 Men game
Kate 18 Women shopping 
Tom 19 Men skydiving
Tom 19 Men fishing </pre><pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.( domain, cnt );

data2 = LOAD <span class="synConstant">'student2.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, hobby:chararray );
group_data2 = <span class="synSpecial">GROUP</span> data2 <span class="synSpecial">BY</span> ( name, age, gen );
list_data2 = FOREACH group_data2 GENERATE FLATTEN( <span class="synSpecial">group</span> ) <span class="synSpecial">AS</span> ( name, age, gen ), data2.hobby;

join_list = JOIN list_data1_uniq <span class="synSpecial">BY</span> (name, age, gen ) FULL OUTER, list_data2 <span class="synSpecial">BY</span> (name, age, gen );

DUMP join_list;

<span class="synComment">/* DESCRIBEの結果 */</span>
join_list: {list_data1_uniq::name: chararray,list_data1_uniq::age: int,list_data1_uniq::gen: chararray,list_data1_uniq::list_data1: {domain: chararray,cnt: <span class="synType">long</span>},list_data2::name: chararray,list_data2::age: int,list_data2::gen: chararray,list_data2::hobby: {hobby: chararray}}

<span class="synComment">/*出力結果*/</span>
(,,,,Ken,<span class="synConstant">17</span>,Men,{(game)})
(Tom,<span class="synConstant">19</span>,Men,{(google,<span class="synConstant">1</span>)},Tom,<span class="synConstant">19</span>,Men,{(skydiving),(fishing)})
(John,<span class="synConstant">17</span>,Men,{(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)},John,<span class="synConstant">17</span>,Men,{(soccer)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)},Kate,<span class="synConstant">18</span>,Women,{(shopping)})
</pre><p>次にGOCROUPの結果を見てみます。上のコードのJOIN〜FULL OUTERの箇所を書き換えます。結果を出力してみるとデータの形式が少しJOINと異なっています。JOINはBYで指定したデータ項目が空だと空として出力していますが、COGROUPの場合はBYで指定したデータが片方で存在しなくても、もう片方のデータを使って出力しています。またJOINはデータを単純に結合したデータとして表示しますが、COGROUPはデータ項目ごとにbag形式に変換して出力します。出力の比較としてはCOGROUPの方が分かりやすいと思うので<span class="deco" style="color:#FF0000;">OUTER JOINをしたい場合はCOGROUPを使う</span>ことを薦めます。さてDESCRIBEの結果はどうなっているかというと、list_data1_uniq.nameのようにドットで参照する必要があります。COGROUPの動作はGROUPを元に作られているようなので<span class="deco" style="color:#FF0000;">GROUP/COGROUPのデータ参照はドット、JOINはダブルコロン</span>と覚えておくと良いと思います。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.( domain, cnt );

data2 = LOAD <span class="synConstant">'student2.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, hobby:chararray );
group_data2 = <span class="synSpecial">GROUP</span> data2 <span class="synSpecial">BY</span> ( name, age, gen );
list_data2 = FOREACH group_data2 GENERATE FLATTEN( <span class="synSpecial">group</span> ) <span class="synSpecial">AS</span> ( name, age, gen ), data2.hobby;

join_list = COGROUP list_data1_uniq <span class="synSpecial">BY</span> (name, age, gen ), list_data2 <span class="synSpecial">BY</span> (name, age, gen );
DESCRIBE join_list;
DUMP join_list;

<span class="synComment">/* DESCRIBEの結果 */</span> 
join_list: {<span class="synSpecial">group</span>: (name: chararray,age: int,gen: chararray),list_data1_uniq: {name: chararray,age: int,gen: chararray,list_data1: {domain: chararray,cnt: <span class="synType">long</span>}},list_data2: {name: chararray,age: int,gen: chararray,hobby: {hobby: chararray}}}

<span class="synComment">/*出力結果*/</span>
((Ken,<span class="synConstant">17</span>,Men),{},{(Ken,<span class="synConstant">17</span>,Men,{(game)})})
((Tom,<span class="synConstant">19</span>,Men),{(Tom,<span class="synConstant">19</span>,Men,{(google,<span class="synConstant">1</span>)})},{(Tom,<span class="synConstant">19</span>,Men,{(skydiving),(fishing)})})
((John,<span class="synConstant">17</span>,Men),{(John,<span class="synConstant">17</span>,Men,{(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)})},{(John,<span class="synConstant">17</span>,Men,{(soccer)})})
((Kate,<span class="synConstant">18</span>,Women),{(Kate,<span class="synConstant">18</span>,Women,{(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)})},{(Kate,<span class="synConstant">18</span>,Women,{(shopping)})})
</pre><p>JOINの例でデータをCOGROUPに近い形式に変換する例を紹介します。FOREACH GENERATEでname,age,genがそれぞれ空かどうかの判定を利用してinput1,input2のどちらか片方からデータを引っ張ってくるような記述をします。嵌ったところとしてはageがint型で定義されているので == '' での空判定を行おうとするとintとchararrayの比較になるので<a class="keyword" href="http://d.hatena.ne.jp/keyword/error">error</a>が表示されます。今回はnullかどうかの判定がしたいので<span class="deco" style="color:#FF0000;">is null</span>または<span class="deco" style="color:#FF0000;">is not null</span>を指定します。ちなみに<span class="deco" style="color:#FF0000;">IsEmpty</span>というPigの標準関数で空かどうかをチェックするものがありますが、<span class="deco" style="color:#FF0000;">bagかmapにしか適用できない</span>ため今回のようなintやchararrayのケースでは利用できません。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.( domain, cnt );

data2 = LOAD <span class="synConstant">'student2.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, hobby:chararray );
group_data2 = <span class="synSpecial">GROUP</span> data2 <span class="synSpecial">BY</span> ( name, age, gen );
list_data2 = FOREACH group_data2 GENERATE FLATTEN( <span class="synSpecial">group</span> ) <span class="synSpecial">AS</span> ( name, age, gen ), data2.hobby;

join_list = JOIN list_data1_uniq <span class="synSpecial">BY</span> (name, age, gen ) FULL OUTER, list_data2 <span class="synSpecial">BY</span> (name, age, gen );
fix_list = FOREACH join_list GENERATE ( list_data2::name <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::name : list_data2::name ),( list_data2::age <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::age : list_data2::age ), ( list_data2::gen <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::gen : list_data2::gen ), list_data1_uniq::list_data1, list_data2::hobby;
DUMP fix_list;

<span class="synComment">/* 出力結果 */</span>
(Ken,<span class="synConstant">17</span>,Men,,{(game)})
(Tom,<span class="synConstant">19</span>,Men,{(google,<span class="synConstant">1</span>)},{(skydiving),(fishing)})
(John,<span class="synConstant">17</span>,Men,{(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)},{(soccer)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)},{(shopping)})
</pre>
</div>
<div class="section">
<h5>JOIN/COGROUPのBY属性にnull項目があるときは気をつける</h5>
<p><span class="deco" style="color:#FF0000;">JOIN/COGROUPのBY属性にnullとなっているデータ項目が存在する時は気をつけましょう。</span>意図しない結合結果になります。1行でまとめたい出力が2行になったりします。対応策としてはnullの項目に何かしら異常を示すデータを入れてしまうことです。ここではintがnullの場合には0を、chararrayがnullの場合は'N/A'を入れるようにしました。まずは異常値を入れない例です。異常値を入れないとJohnの項目が何故か2行出力されてしまいます。</p>
<pre class="code" data-lang="" data-unlink>/* input1 */
John   youtube
John   yahoo
Kate 18 Women facebook
Kate 18 Women ebay
Kate 18 Women ebay
Tom 19 Men google

/* input2 */
John   soccer
Ken 17 Men game
Kate 18 Women shopping 
Tom 19 Men skydiving
Tom 19 Men fishing</pre><pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, <span class="synSpecial">group</span>.domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.( domain, cnt );

data2 = LOAD <span class="synConstant">'student2.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, hobby:chararray );
group_data2 = <span class="synSpecial">GROUP</span> data2 <span class="synSpecial">BY</span> ( name, age, gen );
list_data2 = FOREACH group_data2 GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, data2.hobby;

join_list = JOIN list_data1_uniq <span class="synSpecial">BY</span> (name, age, gen ) FULL OUTER, list_data2 <span class="synSpecial">BY</span> (name, age, gen );
fix_list = FOREACH join_list GENERATE ( list_data2::name <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::name : list_data2::name ),( list_data2::age <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::age : list_data2::age ), ( list_data2::gen <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::gen : list_data2::gen ), list_data1_uniq::list_data1, list_data2::hobby;
DUMP fix_list;

<span class="synComment">/* 出力結果 */</span>
(Ken,<span class="synConstant">17</span>,Men,,{(game)})
(Tom,<span class="synConstant">19</span>,Men,{(google,<span class="synConstant">1</span>)},{(skydiving),(fishing)})
(John,,,{(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)},)
(John,,,,{(soccer)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)},{(shopping)})
</pre><p>次に異常値を入れた例です。Johnの項目が1行で出力されていて意図した結果を得ることが出来ました。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data1 = LOAD <span class="synConstant">'student1.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
group_data1 = <span class="synSpecial">GROUP</span> data1 <span class="synSpecial">BY</span> ( name, age, gen, domain );
list_data1 = FOREACH group_data1 GENERATE <span class="synSpecial">group</span>.name, ( <span class="synSpecial">group</span>.age <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? <span class="synConstant">0</span> : <span class="synSpecial">group</span>.age ) <span class="synSpecial">AS</span> age, ( <span class="synSpecial">group</span>.gen <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? <span class="synConstant">'N/A'</span> : <span class="synSpecial">group</span>.gen ) <span class="synSpecial">AS</span> gen, <span class="synSpecial">group</span>.domain, COUNT( data1.domain ) <span class="synSpecial">AS</span> cnt;

list_data1_group = <span class="synSpecial">GROUP</span> list_data1 <span class="synSpecial">BY</span>( name, age, gen );
list_data1_uniq = FOREACH list_data1_group GENERATE <span class="synSpecial">group</span>.name, <span class="synSpecial">group</span>.age, <span class="synSpecial">group</span>.gen, list_data1.( domain, cnt );

data2 = LOAD <span class="synConstant">'student2.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, hobby:chararray );
group_data2 = <span class="synSpecial">GROUP</span> data2 <span class="synSpecial">BY</span> ( name, age, gen );
list_data2 = FOREACH group_data2 GENERATE <span class="synSpecial">group</span>.name, ( <span class="synSpecial">group</span>.age <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? <span class="synConstant">0</span> : <span class="synSpecial">group</span>.age ) <span class="synSpecial">AS</span> age, ( <span class="synSpecial">group</span>.gen <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? <span class="synConstant">'N/A'</span> : <span class="synSpecial">group</span>.gen ) <span class="synSpecial">AS</span> gen, data2.hobby;

join_list = JOIN list_data1_uniq <span class="synSpecial">BY</span> (name, age, gen ) FULL OUTER, list_data2 <span class="synSpecial">BY</span> (name, age, gen );
fix_list = FOREACH join_list GENERATE ( list_data2::name <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::name : list_data2::name ),( list_data2::age <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::age : list_data2::age ), ( list_data2::gen <span class="synSpecial">is</span> <span class="synSpecial">null</span> ? list_data1_uniq::gen : list_data2::gen ), list_data1_uniq::list_data1, list_data2::hobby;
DUMP fix_list;

<span class="synComment">/* 出力結果 */</span>
Ken <span class="synConstant">17</span> Men     {(game)}
Tom <span class="synConstant">19</span> Men {(google,<span class="synConstant">1</span>)}   {(skydiving),(fishing)}
John    <span class="synConstant">0</span>  N/A {(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)}   {(soccer)}
Kate    <span class="synConstant">18</span> Women   {(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)}   {(shopping)}
</pre>
</div>
<div class="section">
<h5>STOREした時のtuple/bag/mapは文字列として保存される。再度LOADする時はPig形式のデータで読み込みたい時はASで指定する</h5>
<p>上のJOINの結果をresultというディレクトリにSTOREします。STORE alias INTO 'ディレクトリ名' USING PigStorage();という行をDUMPの代わりに記述してあげるだけで保存ができます。PigStorageはdefaultでtab区切りに保存してくれます。実行するとresult/part-r-00000というファイルが生成されているので中身を確認します。確かにtab区切りで保存されていて、tupleやbagは<span class="deco" style="color:#FF0000;">そのまま文字列として記録</span>されています。</p>
<pre class="code" data-lang="" data-unlink>cat result/part-r-00000 
Ken 17  Men     {(game)}
Tom 19  Men {(google,1)}    {(skydiving),(fishing)}
John    17  Men {(yahoo,1),(youtube,1)} {(soccer)}
Kate    18  Women   {(ebay,2),(facebook,1)} {(shopping)}</pre><p>上のデータを再度bag/tuple形式で呼び出したい時は<span class="deco" style="color:#FF0000;">LOAD時にASの中でbagやtupleであることを明示</span>します。定義は他のデータ型と同じで<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE">カラム名</a>:bagや<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE">カラム名</a>:tupleとして宣言します。当然bagやtupleとして宣言せずにchararrayとしてしまうと文字列として扱われてしまうので、()や{}が意味を持たないデータになってしまいます。</p>
<pre class="hljs sql" data-lang="sql" data-unlink>data = LOAD <span class="synConstant">'result/part-r-00000'</span> <span class="synSpecial">USING</span> PigStorage() <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domains:bag{ t:tuple( domain ,cnt ) }, hobbys:bag{ t:tuple( hobby ) } );
DESCRIBE data;
DUMP data;

<span class="synComment">/* DESCRIBE結果 */</span>
data: {name: chararray,age: int,gen: chararray,domains: {t: (domain: bytearray,cnt: bytearray)},hobbys: {t: (hobby: bytearray)}}

<span class="synComment">/* 出力結果 */</span>
(Ken,<span class="synConstant">17</span>,Men,,{(game)})
(Tom,<span class="synConstant">19</span>,Men,{(google,<span class="synConstant">1</span>)},{(skydiving),(fishing)})
(John,<span class="synConstant">17</span>,Men,{(yahoo,<span class="synConstant">1</span>),(youtube,<span class="synConstant">1</span>)},{(soccer)})
(Kate,<span class="synConstant">18</span>,Women,{(ebay,<span class="synConstant">2</span>),(facebook,<span class="synConstant">1</span>)},{(shopping)})
</pre>
</div>
</blockquote>

</div>
<div class="section">
<h4>その他 Tips</h4>

<blockquote>
    <p>データ構造とは直接関係ないですが、Pigを利用することでのTipsを書いておきます。</p>

<div class="section">
<h5>文法をCheckしてlocalで実行し、問題なければ<a class="keyword" href="http://d.hatena.ne.jp/keyword/HDFS">HDFS</a>上で<a class="keyword" href="http://d.hatena.ne.jp/keyword/MapReduce">MapReduce</a>させる</h5>
<p>書いたPIgの文法が正しいかどうかのCheckは-cオプションで確認できます。syntax OKと出れば文法は問題無いように見えるのですが、残念なことに実際動かしていみると動かないケースは多々あります。-cオプションでは本当に簡単な文法しか確認できないようです。PigはLocalModeとHDFSModeがありDefaultはHDFSModeで、LocalModeで実行したい場合はpig -x localと指定します。</p>
<pre class="code" data-lang="" data-unlink>$ pig -c test.pig                <!-- 文法チェック -->
pig -c test.pig 
(略)
2013-01-26 11:59:02,272 [main] WARN  org.apache.pig.tools.grunt.GruntParser - 'dump' statement is ignored while processing 'explain -script' or '-check'
test.pig syntax OK

$ pig -x local test.pig       <!-- LocalModeで実行 -->
(略)
2013-01-26 12:04:51,460 [main] INFO  org.apache.pig.backend.hadoop.executionengine.util.MapRedUtil - Total input paths to process : 1
(John,17,Men,youtube)
(John,17,Men,yahoo)
(Kate,18,Women,facebook)
(Kate,18,Women,ebay)
(Kate,18,Women,ebay)
(Tom,19,Men,google)

$ pig test.pig                    <!-- HDFSModeで実行 --></pre>
</div>
<div class="section">
<h5>Reducerの数を調節したい</h5>
<p>pig<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8">スクリプト</a>内部で行う場合はSET default_parallelでReducerの数値を設定します。</p>
<pre class="hljs sql" data-lang="sql" data-unlink><span class="synStatement">SET</span> default_parallel <span class="synConstant">2000</span>;
data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
</pre>
</div>
<div class="section">
<h5>STOREするDataを<a class="keyword" href="http://d.hatena.ne.jp/keyword/gzip">gzip</a>圧縮したい</h5>
<p>pig<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8">スクリプト</a>内部で行う場合はSET output.compression.enabled true;と SET output.compression.codec org.<a class="keyword" href="http://d.hatena.ne.jp/keyword/apache">apache</a>.<a class="keyword" href="http://d.hatena.ne.jp/keyword/hadoop">hadoop</a>.io.compress.GzipCodec; を指定します。またpig<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8">スクリプト</a>に渡すパラメータとして設定する場合も-Dmapredとして設定することもできます。</p>
<pre class="hljs sql" data-lang="sql" data-unlink><span class="synStatement">SET</span> default_parallel <span class="synConstant">2000</span>;
<span class="synStatement">SET</span> output.compression.enabled <span class="synSpecial">true</span>;
<span class="synStatement">SET</span> output.compression.codec org.apache.hadoop.io.<span class="synSpecial">compress</span>.GzipCodec;
data = LOAD <span class="synConstant">'student.txt'</span> <span class="synSpecial">USING</span> PigStorage( <span class="synConstant">' '</span> ) <span class="synSpecial">AS</span> ( name:chararray, age:int, gen:chararray, domain:chararray );
</pre><pre class="hljs sql" data-lang="sql" data-unlink>$ pig -Dmapred.output.compression.enabled=<span class="synSpecial">true</span> -Dmapred.output.compression.codec=org.apache.hadoop.io.<span class="synSpecial">compress</span>.GzipCodec test.pig
</pre>
</div>
</blockquote>

</div>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://yutakikuchi.github.io/blog/post/201301150833/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://yutakikuchi.github.io/blog/post/201301150833/">スタートアップを目指す人は必読！起業成功マニュアルの前半を読んでまとめを書きました</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="https://yutakikuchi.github.io/blog/post/201302040834/">スタートアップを目指す人は必読！起業成功マニュアルの後半を読んでまとめを書きました</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="https://yutakikuchi.github.io/blog/post/201302040834/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  

</div>

</div>
</div>
<script src="https://yutakikuchi.github.io/blog/js/ui.js"></script>
<script src="https://yutakikuchi.github.io/blog/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-20616165-3', 'auto');
    ga('send', 'pageview');
  }
</script>





</body>
</html>

